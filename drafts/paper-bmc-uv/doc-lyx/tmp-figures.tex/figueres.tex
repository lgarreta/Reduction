%% LyX 2.3.4.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass{article}
\usepackage[latin9]{inputenc}
\begin{document}

\section*{Figures}

\begin{figure}[th]
\caption{\csentence{Protein folding trajectory.} Some protein conformations with their three-dimensional structure are marked as blue dots along the trajectory. The evolution of folding is measured at each step by comparing the structure at time $t_{i}$ to the native structure (black image background) using a structure comparison metric; in this work, we use the TM-score as the metric (see Methods). X-axis: Simulation time from $t_{0}$ to $t_{n}$. Y-axis: TM-score value from 0 (different) to 1 (similar). \label{fig:Folding-Trajectory}. }
\end{figure}

\begin{figure}[th]
\caption{\csentence{Loss of information in dimensionality reduction and clustering.} The dimensionality reduction method (above) transforms the conformations ( $c_{1},c_{5}$, and $c_{7}$) into a new set of values ( $c'_{1},c'_{5}$, and $c'_{7}$), but their structural information is lost, whereas the clustering method (bottom) forms two groups (G1 and G2), but their temporal order is lost since they contain conformations that overlap in time ($c_{2},c_{3},c_{4},c_{5}$). \label{fig:lost-info-dimensionality}}
\end{figure}

\begin{figure}[th]
\caption{\csentence{Overview of the proposed algorithm.} Step 1: Divide the trajectory into segments (vertical dashed lines) and reduce each individually. Each segment has $k$ conformations from time $t_{1}$ to $t_{k}$. Step 2: For each segment, extract characteristic conformations (blue dots) and remove redundant ones (red dots). Step 3: Select the most representative conformations among the previous conformations to obtain a reduced segment. \label{fig:Algorithm-Description}}
\end{figure}

\begin{figure}[th]
\caption{\csentence{Parallel processing of segments.} The trajectory is divided into $m$ segments ($S_{1}$, ..., $S_{m}$), and each segment is processed separately and in parallel on a machine with n processing cores. The results of the extraction and selection steps ($S'_{1}$, ..., $S'_{m}$) are independent of each other and are joined to form the reduced trajectory.\label{fig:Algorithm-Parallel}}
\end{figure}

% Preview source code for paragraph 48

\begin{figure*}[!t]
\caption{\csentence{Plots of the TM-score values for the original and reduced trajectories.} Protein and simulation details on the left. Trajectories on the right: original (upper part), and reduced (lower part). (A) Trajectory of trp-cage protein, reduced by 98\%, from 1044001 to 20881 conformations. (B) Trajectory of SARS CoV2 protein, reduced by 80\%, from 100000 to 2000 conformations. (C) Trajectory of the villin-headpiece protein, reduced by 80\%, from 15201 to 3011 conformations. \label{fig:Trajectory-Results}}
\end{figure*}

\begin{figure}[!th]
\caption{\csentence{Comparison with other methods.} Intrinsic information captured from the original trajectory of the villin-headpiece protein is largely preserved in the reduced trajectories produced by our algorithm. TM-score plot, nMDS pattern and clustering groups are presented at the top, bottom left, and bottom right of each panel. (A) Original trajectory. (B and C) Trajectories reduced by 52\% and 80\%, respectively. The nMDS produces a set of circular patterns associated with conformations occurring in different times of the simulation, whereas clustering produces a structure of three clusters associated with the first two principal components of the $C_{\alpha}$atoms of the conformations. \label{fig:Comparaciones-PCA-nMDS}}
\end{figure}

\begin{figure}[th]
\caption{\csentence{Performance of the algorithm.} (A) Runtime comparisons for four folding reduction techniques: nMDS, clustering, PCA, and our proposed algorithm (running with one and two cores). With one core, PCA was the most efficient algorithm, followed by our algorithm. However, when the proposed algorithm was run with two cores, its runtime was reduced by half, being more efficient than PCA. (B) Evaluation of algorithm parallelization. When the number of processing cores is multiplied by two, the processing time reduces by half with a quasi-linear speedup that is maintained for up to \textasciitilde 8 cores (8x). \label{fig:Performance-methods}}
\end{figure}

\end{document}
